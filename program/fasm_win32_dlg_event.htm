<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><script type="text/javascript" src="../page_head.js"></script>

<h3><a href="../program.htm">程式語言</a> - Flat Assembler (FASM) - Win32 API - Dialog - <b>Handle Event</b></h3>
<hr size="1"><br>
<p>
參考資訊：<br>
https://board.flatassembler.net/<br><br>

一般在建立Windows視窗時，會註冊自定義的Class並且設定事件處理的副程式(callback)，不過，目前範例使用的Class是系統預設的WC_DIALOG，因此，可以透過SetWindowLong()設定callback，這種替換callback的行為就稱為Subclass，意指為原本Class的Subclass，所以Subclass後，需要將原先callback的位址(SetWindowLong()的回傳值)保存下來，然後透過呼叫CallWindowProc()(傳入原先callback的位址)，用來將處理控制權移交回原先視窗元件，所以當有多層Subclass的情形發生時，每次在處理事件時，記得判斷對應的Handle，如：在處理關閉事件時(WM_CLOSE)，會先判斷目前的hWnd是否為當前的視窗hWnd，如果是當前視窗hWnd，才進行關閉的動作，避免關閉到其它視窗元件<br><br>

main.asm
</p>
<pre class="brush:asm">
    format PE GUI 4.0
    entry start
 
    include "c:\fasm\include\win32a.inc"

    section ".idata" import data readable writeable
library user, "user32.dll", kernel, "kernel32.dll"
 
import user,                             \
    MessageBox,      "MessageBoxA",      \
    GetMessage,      "GetMessageA",      \
    DestroyWindow,   "DestroyWindow",    \
    SetWindowLong,   "SetWindowLongA",   \
    CreateWindowEx,  "CreateWindowExA",  \
    CallWindowProc,  "CallWindowProcA",  \
    DispatchMessage, "DispatchMessageA", \
    PostQuitMessage, "PostQuitMessage"

import kernel,                           \
    ExitProcess,     "ExitProcess",      \
    GetCommandLine,  "GetCommandLineA",  \
    GetModuleHandle, "GetModuleHandleA"
 
    section ".data" data readable writeable
hWin        dd 0
szCaption   db "main",0
hInstance   dd 0
CommandLine dd 0
defWndProc  dd 0

    section ".text" code readable executable
proc WndProc hWnd, uMsg, wParam, lParam
    mov eax, [uMsg]
    cmp eax, WM_CLOSE
    je .handle_close
    cmp eax, WM_DESTROY
    je .handle_destroy
    invoke CallWindowProc, [defWndProc], [hWnd], [uMsg], [wParam], [lParam]
    jmp .finish

.handle_close:
    invoke DestroyWindow, [hWnd]
    xor eax, eax
    jmp .finish

.handle_destroy:
    invoke PostQuitMessage, 0
    xor eax, eax
    jmp .finish
 
.finish:
    ret
endp

proc WinMain hInst, hPrevInst, CmdLine, CmdShow
    local msg:MSG

    invoke CreateWindowEx, WS_EX_LEFT, WC_DIALOG, szCaption, \
        WS_OVERLAPPEDWINDOW or WS_VISIBLE, 0, 0, 300, 300, NULL, NULL, NULL, NULL
    mov [hWin], eax

    invoke SetWindowLong, [hWin], GWL_WNDPROC, WndProc
    mov [defWndProc], eax

@@:
    lea eax, [msg]
    invoke GetMessage, eax, NULL, 0, 0
    cmp eax, 0
    je @f
    lea eax, [msg]
    invoke DispatchMessage, eax
    jmp @b
@@:
    mov eax, [msg.wParam]
    ret
endp

start:
    invoke GetModuleHandle, NULL
    mov [hInstance], eax
 
    invoke GetCommandLine
    mov [CommandLine], eax
 
    stdcall WinMain, [hInstance], NULL, [CommandLine], SW_SHOWNORMAL
    invoke ExitProcess, eax
</pre>
<p>
<b>Line 34~37</b>：關閉視窗的順序為：主視窗收到WM_CLOSE事件時，呼叫DestroyWindow()，DestroyWindow()會自動將子視窗的相關資源也一併釋放掉(包含Resource描述的資源)，系統接著會發送WM_DESTROY事件給主視窗，待主視窗收到WM_DESTROY事件時，呼叫PostQuitMessage()結束視窗，值得注意的地方是，SendMessage()是屬於Block方式呼叫(必須等待動作執行完畢才返回)，而PostQuitMessage()則是Non-block方式呼叫<br>
<b>Line 38</b>：將處理控制權移交給下一個視窗元件</br><br>

完成<br>
<img style="border:0px" src="nasm_win32_dlg_window/1.jpg" class="maxSize">
</p>

<br><script type="text/javascript" src="../tail.js"></script>
